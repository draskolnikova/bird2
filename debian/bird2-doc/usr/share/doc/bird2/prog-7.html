<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 1.0.9">
 <TITLE>BIRD Programmer's Documentation: Library functions</TITLE>
 <LINK HREF="prog-8.html" REL=next>
 <LINK HREF="prog-6.html" REL=previous>
 <LINK HREF="prog.html#toc7" REL=contents>
</HEAD>
<BODY>
<A HREF="prog-8.html">Next</A>
<A HREF="prog-6.html">Previous</A>
<A HREF="prog.html#toc7">Contents</A>
<HR>
<H2><A NAME="s7">7.</A> <A HREF="prog.html#toc7">Library functions</A></H2>

<H2><A NAME="ss7.1">7.1</A> <A HREF="prog.html#toc7.1">IP addresses</A>
</H2>

<P>
<P>BIRD uses its own abstraction of IP address in order to share the same
code for both IPv4 and IPv6. IP addresses are represented as entities
of type <I>ip_addr</I> which are never to be treated as numbers and instead
they must be manipulated using the following functions and macros.
<P>
<P><HR><H3>Function</H3>
<P><I>char *</I>
<B>ip_scope_text</B>
(<I>uint</I> <B>scope</B>) --     get textual representation of address scope
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>uint</I> <B>scope</B><DD><P>scope (<I>SCOPE_xxx</I>)
</DL>
<H3>Description</H3>
<P>Returns a pointer to a textual name of the scope given.


<HR><H3>Function</H3>
<P><I>int</I>
<B>ipa_equal</B>
(<I>ip_addr</I> <B>x</B>, <I>ip_addr</I> <B>y</B>) --     compare two IP addresses for equality
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>ip_addr</I> <B>x</B><DD><P>IP address
<DT><I>ip_addr</I> <B>y</B><DD><P>IP address
</DL>
<H3>Description</H3>
<P><B>ipa_equal()</B> returns 1 if <B>x</B> and <B>y</B> represent the same IP address, else 0.


<HR><H3>Function</H3>
<P><I>int</I>
<B>ipa_nonzero</B>
(<I>ip_addr</I> <B>x</B>) --     test if an IP address is defined
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>ip_addr</I> <B>x</B><DD><P>IP address
</DL>
<H3>Description</H3>
<P>ipa_nonzero returns 1 if <B>x</B> is a defined IP address (not all bits are zero),
else 0.
<P>The undefined all-zero address is reachable as a <CODE>IPA_NONE</CODE> macro.


<HR><H3>Function</H3>
<P><I>ip_addr</I>
<B>ipa_and</B>
(<I>ip_addr</I> <B>x</B>, <I>ip_addr</I> <B>y</B>) --     compute bitwise and of two IP addresses
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>ip_addr</I> <B>x</B><DD><P>IP address
<DT><I>ip_addr</I> <B>y</B><DD><P>IP address
</DL>
<H3>Description</H3>
<P>This function returns a bitwise and of <B>x</B> and <B>y</B>. It's primarily
used for network masking.


<HR><H3>Function</H3>
<P><I>ip_addr</I>
<B>ipa_or</B>
(<I>ip_addr</I> <B>x</B>, <I>ip_addr</I> <B>y</B>) --     compute bitwise or of two IP addresses
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>ip_addr</I> <B>x</B><DD><P>IP address
<DT><I>ip_addr</I> <B>y</B><DD><P>IP address
</DL>
<H3>Description</H3>
<P>This function returns a bitwise or of <B>x</B> and <B>y</B>.


<HR><H3>Function</H3>
<P><I>ip_addr</I>
<B>ipa_xor</B>
(<I>ip_addr</I> <B>x</B>, <I>ip_addr</I> <B>y</B>) --     compute bitwise xor of two IP addresses
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>ip_addr</I> <B>x</B><DD><P>IP address
<DT><I>ip_addr</I> <B>y</B><DD><P>IP address
</DL>
<H3>Description</H3>
<P>This function returns a bitwise xor of <B>x</B> and <B>y</B>.


<HR><H3>Function</H3>
<P><I>ip_addr</I>
<B>ipa_not</B>
(<I>ip_addr</I> <B>x</B>) --     compute bitwise negation of two IP addresses
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>ip_addr</I> <B>x</B><DD><P>IP address
</DL>
<H3>Description</H3>
<P>This function returns a bitwise negation of <B>x</B>.


<HR><H3>Function</H3>
<P><I>ip_addr</I>
<B>ipa_mkmask</B>
(<I>int</I> <B>x</B>) --     create a netmask
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>int</I> <B>x</B><DD><P>prefix length
</DL>
<H3>Description</H3>
<P>This function returns an <I>ip_addr</I> corresponding of a netmask
of an address prefix of size <B>x</B>.


<HR><H3>Function</H3>
<P><I>int</I>
<B>ipa_masklen</B>
(<I>ip_addr</I> <B>x</B>) --     calculate netmask length
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>ip_addr</I> <B>x</B><DD><P>IP address
</DL>
<H3>Description</H3>
<P>This function checks whether <B>x</B> represents a valid netmask and
returns the size of the associate network prefix or -1 for invalid
mask.


<HR><H3>Function</H3>
<P><I>int</I>
<B>ipa_hash</B>
(<I>ip_addr</I> <B>x</B>) --     hash IP addresses
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>ip_addr</I> <B>x</B><DD><P>IP address
</DL>
<H3>Description</H3>
<P><B>ipa_hash()</B> returns a 16-bit hash value of the IP address <B>x</B>.


<HR><H3>Function</H3>
<P><I>void</I>
<B>ipa_hton</B>
(<I>ip_addr</I> <B>x</B>) --     convert IP address to network order
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>ip_addr</I> <B>x</B><DD><P>IP address
</DL>
<H3>Description</H3>
<P>Converts the IP address <B>x</B> to the network byte order.
<P>Beware, this is a macro and it alters the argument!


<HR><H3>Function</H3>
<P><I>void</I>
<B>ipa_ntoh</B>
(<I>ip_addr</I> <B>x</B>) --     convert IP address to host order
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>ip_addr</I> <B>x</B><DD><P>IP address
</DL>
<H3>Description</H3>
<P>Converts the IP address <B>x</B> from the network byte order.
<P>Beware, this is a macro and it alters the argument!


<HR><H3>Function</H3>
<P><I>int</I>
<B>ipa_classify</B>
(<I>ip_addr</I> <B>x</B>) --     classify an IP address
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>ip_addr</I> <B>x</B><DD><P>IP address
</DL>
<H3>Description</H3>
<P><B>ipa_classify()</B> returns an address class of <B>x</B>, that is a bitwise or
of address type (<I>IADDR_INVALID</I>, <I>IADDR_HOST</I>, <I>IADDR_BROADCAST</I>, <I>IADDR_MULTICAST</I>)
with address scope (<I>SCOPE_HOST</I> to <I>SCOPE_UNIVERSE</I>) or -1 (<I>IADDR_INVALID</I>)
for an invalid address.


<HR><H3>Function</H3>
<P><I>ip4_addr</I>
<B>ip4_class_mask</B>
(<I>ip4_addr</I> <B>x</B>) --     guess netmask according to address class
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>ip4_addr</I> <B>x</B><DD><P>IPv4 address
</DL>
<H3>Description</H3>
<P>This function (available in IPv4 version only) returns a
network mask according to the address class of <B>x</B>. Although
classful addressing is nowadays obsolete, there still live
routing protocols transferring no prefix lengths nor netmasks
and this function could be useful to them.


<HR><H3>Function</H3>
<P><I>u32</I>
<B>ipa_from_u32</B>
(<I>ip_addr</I> <B>x</B>) --     convert IPv4 address to an integer
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>ip_addr</I> <B>x</B><DD><P>IP address
</DL>
<H3>Description</H3>
<P>This function takes an IPv4 address and returns its numeric
representation.


<HR><H3>Function</H3>
<P><I>ip_addr</I>
<B>ipa_to_u32</B>
(<I>u32</I> <B>x</B>) --     convert integer to IPv4 address
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>u32</I> <B>x</B><DD><P>a 32-bit integer
</DL>
<H3>Description</H3>
<P><B>ipa_to_u32()</B> takes a numeric representation of an IPv4 address
and converts it to the corresponding <I>ip_addr</I>.


<HR><H3>Function</H3>
<P><I>int</I>
<B>ipa_compare</B>
(<I>ip_addr</I> <B>x</B>, <I>ip_addr</I> <B>y</B>) --     compare two IP addresses for order
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>ip_addr</I> <B>x</B><DD><P>IP address
<DT><I>ip_addr</I> <B>y</B><DD><P>IP address
</DL>
<H3>Description</H3>
<P>The <B>ipa_compare()</B> function takes two IP addresses and returns
-1 if <B>x</B> is less than <B>y</B> in canonical ordering (lexicographical
order of the bit strings), 1 if <B>x</B> is greater than <B>y</B> and 0
if they are the same.


<HR><H3>Function</H3>
<P><I>ip_addr</I>
<B>ipa_build6</B>
(<I>u32</I> <B>a1</B>, <I>u32</I> <B>a2</B>, <I>u32</I> <B>a3</B>, <I>u32</I> <B>a4</B>) --     build an IPv6 address from parts
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>u32</I> <B>a1</B><DD><P>part #1
<DT><I>u32</I> <B>a2</B><DD><P>part #2
<DT><I>u32</I> <B>a3</B><DD><P>part #3
<DT><I>u32</I> <B>a4</B><DD><P>part #4
</DL>
<H3>Description</H3>
<P><B>ipa_build()</B> takes <B>a1</B> to <B>a4</B> and assembles them to a single IPv6
address. It's used for example when a protocol wants to bind its
socket to a hard-wired multicast address.


<HR><H3>Function</H3>
<P><I>char *</I>
<B>ip_ntop</B>
(<I>ip_addr</I> <B>a</B>, <I>char *</I> <B>buf</B>) --     convert IP address to textual representation
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>ip_addr</I> <B>a</B><DD><P>IP address
<DT><I>char *</I> <B>buf</B><DD><P>buffer of size at least <I>STD_ADDRESS_P_LENGTH</I>
</DL>
<H3>Description</H3>
<P>This function takes an IP address and creates its textual
representation for presenting to the user.


<HR><H3>Function</H3>
<P><I>char *</I>
<B>ip_ntox</B>
(<I>ip_addr</I> <B>a</B>, <I>char *</I> <B>buf</B>) --     convert IP address to hexadecimal representation
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>ip_addr</I> <B>a</B><DD><P>IP address
<DT><I>char *</I> <B>buf</B><DD><P>buffer of size at least <I>STD_ADDRESS_P_LENGTH</I>
</DL>
<H3>Description</H3>
<P>This function takes an IP address and creates its hexadecimal
textual representation. Primary use: debugging dumps.


<HR><H3>Function</H3>
<P><I>int</I>
<B>ip_pton</B>
(<I>char *</I> <B>a</B>, <I>ip_addr *</I> <B>o</B>) --     parse textual representation of IP address
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>char *</I> <B>a</B><DD><P>textual representation
<DT><I>ip_addr *</I> <B>o</B><DD><P>where to put the resulting address
</DL>
<H3>Description</H3>
<P>This function parses a textual IP address representation and
stores the decoded address to a variable pointed to by <B>o</B>.
Returns 0 if a parse error has occurred, else 0.

<H2><A NAME="ss7.2">7.2</A> <A HREF="prog.html#toc7.2">Linked lists</A>
</H2>

<P>
<P>The BIRD library provides a set of functions for operating on linked
lists. The lists are internally represented as standard doubly linked
lists with synthetic head and tail which makes all the basic operations
run in constant time and contain no extra end-of-list checks. Each list
is described by a <I>list</I> structure, nodes can have any format as long
as they start with a <I>node</I> structure. If you want your nodes to belong
to multiple lists at once, you can embed multiple <I>node</I> structures in them
and use the <B>SKIP_BACK()</B> macro to calculate a pointer to the start of the
structure from a <I>node</I> pointer, but beware of obscurity.
<P>There also exist safe linked lists (<I>slist</I>, <I>snode</I> and all functions
being prefixed with <CODE>s_</CODE>) which support asynchronous walking very
similar to that used in the <I>fib</I> structure.
<P>
<P><HR><H3>Function</H3>
<P><I>LIST_INLINE void</I>
<B>add_tail</B>
(<I>list *</I> <B>l</B>, <I>node *</I> <B>n</B>) --     append a node to a list
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>list *</I> <B>l</B><DD><P>linked list
<DT><I>node *</I> <B>n</B><DD><P>list node
</DL>
<H3>Description</H3>
<P><B>add_tail()</B> takes a node <B>n</B> and appends it at the end of the list <B>l</B>.


<HR><H3>Function</H3>
<P><I>LIST_INLINE void</I>
<B>add_head</B>
(<I>list *</I> <B>l</B>, <I>node *</I> <B>n</B>) --     prepend a node to a list
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>list *</I> <B>l</B><DD><P>linked list
<DT><I>node *</I> <B>n</B><DD><P>list node
</DL>
<H3>Description</H3>
<P><B>add_head()</B> takes a node <B>n</B> and prepends it at the start of the list <B>l</B>.


<HR><H3>Function</H3>
<P><I>LIST_INLINE void</I>
<B>insert_node</B>
(<I>node *</I> <B>n</B>, <I>node *</I> <B>after</B>) --     insert a node to a list
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>node *</I> <B>n</B><DD><P>a new list node
<DT><I>node *</I> <B>after</B><DD><P>a node of a list
</DL>
<H3>Description</H3>
<P>Inserts a node <B>n</B> to a linked list after an already inserted
node <B>after</B>.


<HR><H3>Function</H3>
<P><I>LIST_INLINE void</I>
<B>rem_node</B>
(<I>node *</I> <B>n</B>) --     remove a node from a list
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>node *</I> <B>n</B><DD><P>node to be removed
</DL>
<H3>Description</H3>
<P>Removes a node <B>n</B> from the list it's linked in. Afterwards, node <B>n</B> is cleared.


<HR><H3>Function</H3>
<P><I>LIST_INLINE void</I>
<B>update_node</B>
(<I>node *</I> <B>n</B>) --     update node after calling realloc on it
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>node *</I> <B>n</B><DD><P>node to be updated
</DL>
<H3>Description</H3>
<P>Fixes neighbor pointers.


<HR><H3>Function</H3>
<P><I>LIST_INLINE void</I>
<B>init_list</B>
(<I>list *</I> <B>l</B>) --     create an empty list
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>list *</I> <B>l</B><DD><P>list
</DL>
<H3>Description</H3>
<P><B>init_list()</B> takes a <I>list</I> structure and initializes its
fields, so that it represents an empty list.


<HR><H3>Function</H3>
<P><I>LIST_INLINE void</I>
<B>add_tail_list</B>
(<I>list *</I> <B>to</B>, <I>list *</I> <B>l</B>) --     concatenate two lists
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>list *</I> <B>to</B><DD><P>destination list
<DT><I>list *</I> <B>l</B><DD><P>source list
</DL>
<H3>Description</H3>
<P>This function appends all elements of the list <B>l</B> to
the list <B>to</B> in constant time.

<H2><A NAME="ss7.3">7.3</A> <A HREF="prog.html#toc7.3">Miscellaneous functions.</A>
</H2>

<P>
<P>
<P><HR><H3>Function</H3>
<P><I>int</I>
<B>ipsum_verify</B>
(<I>void *</I> <B>frag</B>, <I>uint</I> <B>len</B>, <I>...</I> <B>...</B>) --     verify an IP checksum
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>void *</I> <B>frag</B><DD><P>first packet fragment
<DT><I>uint</I> <B>len</B><DD><P>length in bytes
<DT><I>...</I> <B>...</B><DD><P>variable arguments
</DL>
<H3>Description</H3>
<P>This function verifies whether a given fragmented packet
has correct one's complement checksum as used by the IP
protocol.
<P>It uses all the clever tricks described in RFC 1071 to speed
up checksum calculation as much as possible.
<H3>Result</H3>
<P>1 if the checksum is correct, 0 else.


<HR><H3>Function</H3>
<P><I>u16</I>
<B>ipsum_calculate</B>
(<I>void *</I> <B>frag</B>, <I>uint</I> <B>len</B>, <I>...</I> <B>...</B>) --     compute an IP checksum
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>void *</I> <B>frag</B><DD><P>first packet fragment
<DT><I>uint</I> <B>len</B><DD><P>length in bytes
<DT><I>...</I> <B>...</B><DD><P>variable arguments
</DL>
<H3>Description</H3>
<P>This function calculates a one's complement checksum of a given fragmented
packet.
<P>It uses all the clever tricks described in RFC 1071 to speed
up checksum calculation as much as possible.


<HR><H3>Function</H3>
<P><I>u32</I>
<B>u32_mkmask</B>
(<I>uint</I> <B>n</B>) --     create a bit mask
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>uint</I> <B>n</B><DD><P>number of bits
</DL>
<H3>Description</H3>
<P><B>u32_mkmask()</B> returns an unsigned 32-bit integer which binary
representation consists of <B>n</B> ones followed by zeroes.


<HR><H3>Function</H3>
<P><I>uint</I>
<B>u32_masklen</B>
(<I>u32</I> <B>x</B>) --     calculate length of a bit mask
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>u32</I> <B>x</B><DD><P>bit mask
</DL>
<H3>Description</H3>
<P>This function checks whether the given integer <B>x</B> represents
a valid bit mask (binary representation contains first ones, then
zeroes) and returns the number of ones or 255 if the mask is invalid.


<HR><H3>Function</H3>
<P><I>u32</I>
<B>u32_log2</B>
(<I>u32</I> <B>v</B>) --     compute a binary logarithm.
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>u32</I> <B>v</B><DD><P>number
</DL>
<H3>Description</H3>
<P>This function computes a integral part of binary logarithm of given
integer <B>v</B> and returns it. The computed value is also an index of the
most significant non-zero bit position.


<HR><H3>Function</H3>
<P><I>int</I>
<B>patmatch</B>
(<I>byte *</I> <B>p</B>, <I>byte *</I> <B>s</B>) --     match shell-like patterns
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>byte *</I> <B>p</B><DD><P>pattern
<DT><I>byte *</I> <B>s</B><DD><P>string
</DL>
<H3>Description</H3>
<P><B>patmatch()</B> returns whether given string <B>s</B> matches the given shell-like
pattern <B>p</B>. The patterns consist of characters (which are matched literally),
question marks which match any single character, asterisks which match any
(possibly empty) string of characters and backslashes which are used to
escape any special characters and force them to be treated literally.
<P>The matching process is not optimized with respect to time, so please
avoid using this function for complex patterns.


<HR><H3>Function</H3>
<P><I>int</I>
<B>bvsnprintf</B>
(<I>char *</I> <B>buf</B>, <I>int</I> <B>size</B>, <I>const char *</I> <B>fmt</B>, <I>va_list</I> <B>args</B>) --     BIRD's <B>vsnprintf()</B>
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>char *</I> <B>buf</B><DD><P>destination buffer
<DT><I>int</I> <B>size</B><DD><P>size of the buffer
<DT><I>const char *</I> <B>fmt</B><DD><P>format string
<DT><I>va_list</I> <B>args</B><DD><P>a list of arguments to be formatted
</DL>
<H3>Description</H3>
<P>This functions acts like ordinary <B>sprintf()</B> except that it checks available
<H3>space to avoid buffer overflows and it allows some more format specifiers</H3>
<P><CODE><I>I</I></CODE> for formatting of IP addresses (width of 1 is automatically replaced by
standard IP address width which depends on whether we use IPv4 or IPv6; <CODE><I>I4</I></CODE>
or <CODE><I>I6</I></CODE> can be used for explicit ip4_addr / ip6_addr arguments, <CODE><I>N</I></CODE> for
generic network addresses (net_addr *), <CODE><I>R</I></CODE> for Router / Network ID (u32
value printed as IPv4 address), <CODE><I>lR</I></CODE> for 64bit Router / Network ID (u64
<H3>value printed as eight </H3>
<P>-separated octets), <CODE><I>t</I></CODE> for time values (btime) with
specified subsecond precision, and <CODE><I>m</I></CODE> resp. <CODE><I>M</I></CODE> for error messages (uses
<B>strerror()</B> to translate <B>errno</B> code to message text). On the other hand, it
doesn't support floating point numbers. The <B>bvsnprintf()</B> supports <CODE><I>h</I></CODE> and
<CODE><I>l</I></CODE> qualifiers, but <CODE><I>l</I></CODE> is used for s64/u64 instead of long/ulong.
<H3>Result</H3>
<P>number of characters of the output string or -1 if
the buffer space was insufficient.


<HR><H3>Function</H3>
<P><I>int</I>
<B>bvsprintf</B>
(<I>char *</I> <B>buf</B>, <I>const char *</I> <B>fmt</B>, <I>va_list</I> <B>args</B>) --     BIRD's <B>vsprintf()</B>
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>char *</I> <B>buf</B><DD><P>buffer
<DT><I>const char *</I> <B>fmt</B><DD><P>format string
<DT><I>va_list</I> <B>args</B><DD><P>a list of arguments to be formatted
</DL>
<H3>Description</H3>
<P>This function is equivalent to <B>bvsnprintf()</B> with an infinite
buffer size. Please use carefully only when you are absolutely
sure the buffer won't overflow.


<HR><H3>Function</H3>
<P><I>int</I>
<B>bsprintf</B>
(<I>char *</I> <B>buf</B>, <I>const char *</I> <B>fmt</B>, <I>...</I> <B>...</B>) --     BIRD's <B>sprintf()</B>
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>char *</I> <B>buf</B><DD><P>buffer
<DT><I>const char *</I> <B>fmt</B><DD><P>format string
<DT><I>...</I> <B>...</B><DD><P>variable arguments
</DL>
<H3>Description</H3>
<P>This function is equivalent to <B>bvsnprintf()</B> with an infinite
buffer size and variable arguments instead of a <I>va_list</I>.
Please use carefully only when you are absolutely
sure the buffer won't overflow.


<HR><H3>Function</H3>
<P><I>int</I>
<B>bsnprintf</B>
(<I>char *</I> <B>buf</B>, <I>int</I> <B>size</B>, <I>const char *</I> <B>fmt</B>, <I>...</I> <B>...</B>) --     BIRD's <B>snprintf()</B>
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>char *</I> <B>buf</B><DD><P>buffer
<DT><I>int</I> <B>size</B><DD><P>buffer size
<DT><I>const char *</I> <B>fmt</B><DD><P>format string
<DT><I>...</I> <B>...</B><DD><P>variable arguments
</DL>
<H3>Description</H3>
<P>This function is equivalent to <B>bsnprintf()</B> with variable arguments instead of a <I>va_list</I>.


<HR><H3>Function</H3>
<P><I>void *</I>
<B>xmalloc</B>
(<I>uint</I> <B>size</B>) --     malloc with checking
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>uint</I> <B>size</B><DD><P>block size
</DL>
<H3>Description</H3>
<P>This function is equivalent to <B>malloc()</B> except that in case of
failure it calls <B>die()</B> to quit the program instead of returning
a <I>NULL</I> pointer.
<P>Wherever possible, please use the memory resources instead.


<HR><H3>Function</H3>
<P><I>void *</I>
<B>xrealloc</B>
(<I>void *</I> <B>ptr</B>, <I>uint</I> <B>size</B>) --     realloc with checking
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>void *</I> <B>ptr</B><DD><P>original memory block
<DT><I>uint</I> <B>size</B><DD><P>block size
</DL>
<H3>Description</H3>
<P>This function is equivalent to <B>realloc()</B> except that in case of
failure it calls <B>die()</B> to quit the program instead of returning
a <I>NULL</I> pointer.
<P>Wherever possible, please use the memory resources instead.

<H2><A NAME="ss7.4">7.4</A> <A HREF="prog.html#toc7.4">Message authentication codes</A>
</H2>

<P>
<P>MAC algorithms are simple cryptographic tools for message authentication.
They use shared a secret key a and message text to generate authentication
code, which is then passed with the message to the other side, where the code
is verified. There are multiple families of MAC algorithms based on different
cryptographic primitives, BIRD implements two MAC families which use hash
functions.
<P>The first family is simply a cryptographic hash camouflaged as MAC algorithm.
Originally supposed to be (m|k)-hash (message is concatenated with key, and
that is hashed), but later it turned out that a raw hash is more practical.
This is used for cryptographic authentication in OSPFv2, RIP and BFD.
<P>The second family is the standard HMAC (RFC 2104), using inner and outer hash
to process key and message. HMAC (with SHA) is used in advanced OSPF and RIP
authentication (RFC 5709, RFC 4822).
<P>
<P><HR><H3>Function</H3>
<P><I>void</I>
<B>mac_init</B>
(<I>struct mac_context *</I> <B>ctx</B>, <I>uint</I> <B>id</B>, <I>const byte *</I> <B>key</B>, <I>uint</I> <B>keylen</B>) --     initialize MAC algorithm
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>struct mac_context *</I> <B>ctx</B><DD><P>context to initialize
<DT><I>uint</I> <B>id</B><DD><P>MAC algorithm ID
<DT><I>const byte *</I> <B>key</B><DD><P>MAC key
<DT><I>uint</I> <B>keylen</B><DD><P>MAC key length
</DL>
<H3>Description</H3>
<P>Initialize MAC context <B>ctx</B> for algorithm <B>id</B> (e.g., <I>ALG_HMAC_SHA1</I>), with
key <B>key</B> of length <B>keylen</B>. After that, message data could be added using
<B>mac_update()</B> function.


<HR><H3>Function</H3>
<P><I>void</I>
<B>mac_update</B>
(<I>struct mac_context *</I> <B>ctx</B>, <I>const byte *</I> <B>data</B>, <I>uint</I> <B>datalen</B>) --     add more data to MAC algorithm
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>struct mac_context *</I> <B>ctx</B><DD><P>MAC context
<DT><I>const byte *</I> <B>data</B><DD><P>data to add
<DT><I>uint</I> <B>datalen</B><DD><P>length of data
</DL>
<H3>Description</H3>
<P>Push another <B>datalen</B> bytes of data pointed to by <B>data</B> into the MAC
algorithm currently in <B>ctx</B>. Can be called multiple times for the same MAC
context. It has the same effect as concatenating all the data together and
passing them at once.


<HR><H3>Function</H3>
<P><I>byte *</I>
<B>mac_final</B>
(<I>struct mac_context *</I> <B>ctx</B>) --     finalize MAC algorithm
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>struct mac_context *</I> <B>ctx</B><DD><P>MAC context
</DL>
<H3>Description</H3>
<P>Finish MAC computation and return a pointer to the result. No more
<B>mac_update</B>() calls could be done, but the context may be reinitialized
later.
<P>Note that the returned pointer points into data in the <B>ctx</B> context. If it
ceases to exist, the pointer becomes invalid.


<HR><H3>Function</H3>
<P><I>void</I>
<B>mac_cleanup</B>
(<I>struct mac_context *</I> <B>ctx</B>) --     cleanup MAC context
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>struct mac_context *</I> <B>ctx</B><DD><P>MAC context
</DL>
<H3>Description</H3>
<P>Cleanup MAC context after computation (by filling with zeros). Not strictly
necessary, just to erase sensitive data from stack. This also invalidates the
pointer returned by <B>mac_final</B>().


<HR><H3>Function</H3>
<P><I>void</I>
<B>mac_fill</B>
(<I>uint</I> <B>id</B>, <I>const byte *</I> <B>key</B>, <I>uint</I> <B>keylen</B>, <I>const byte *</I> <B>data</B>, <I>uint</I> <B>datalen</B>, <I>byte *</I> <B>mac</B>) --     compute and fill MAC
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>uint</I> <B>id</B><DD><P>MAC algorithm ID
<DT><I>const byte *</I> <B>key</B><DD><P>secret key
<DT><I>uint</I> <B>keylen</B><DD><P>key length
<DT><I>const byte *</I> <B>data</B><DD><P>message data
<DT><I>uint</I> <B>datalen</B><DD><P>message length
<DT><I>byte *</I> <B>mac</B><DD><P>place to fill MAC
</DL>
<H3>Description</H3>
<P>Compute MAC for specified key <B>key</B> and message <B>data</B> using algorithm <B>id</B> and
copy it to buffer <B>mac</B>. <B>mac_fill()</B> is a shortcut function doing all usual
steps for transmitted messages.


<HR><H3>Function</H3>
<P><I>int</I>
<B>mac_verify</B>
(<I>uint</I> <B>id</B>, <I>const byte *</I> <B>key</B>, <I>uint</I> <B>keylen</B>, <I>const byte *</I> <B>data</B>, <I>uint</I> <B>datalen</B>, <I>const byte *</I> <B>mac</B>) --     compute and verify MAC
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>uint</I> <B>id</B><DD><P>MAC algorithm ID
<DT><I>const byte *</I> <B>key</B><DD><P>secret key
<DT><I>uint</I> <B>keylen</B><DD><P>key length
<DT><I>const byte *</I> <B>data</B><DD><P>message data
<DT><I>uint</I> <B>datalen</B><DD><P>message length
<DT><I>const byte *</I> <B>mac</B><DD><P>received MAC
</DL>
<H3>Description</H3>
<P>Compute MAC for specified key <B>key</B> and message <B>data</B> using algorithm <B>id</B> and
compare it with received <B>mac</B>, return whether they are the same. <B>mac_verify()</B>
is a shortcut function doing all usual steps for received messages.

<H2><A NAME="ss7.5">7.5</A> <A HREF="prog.html#toc7.5">Flow specification (flowspec)</A>
</H2>

<P>
<P>Flowspec are rules (RFC 5575) for firewalls disseminated using BGP protocol.
The <CODE>flowspec.c</CODE> is a library for handling flowspec binary streams and
flowspec data structures. You will find there functions for validation
incoming flowspec binary streams, iterators for jumping over components,
functions for handling a length and functions for formatting flowspec data
structure into user-friendly text representation.
<P>In this library, you will find also flowspec builder. In <CODE>confbase.Y</CODE>, there
are grammar's rules for parsing and building new flowspec data structure
from BIRD's configuration files and from BIRD's command line interface.
Finalize function will assemble final <I>net_addr_flow4</I> or <I>net_addr_flow6</I>
data structure.
<P>The data structures <I>net_addr_flow4</I> and <I>net_addr_flow6</I> are defined in
<CODE>net.h</CODE> file. The attribute length is size of whole data structure plus
binary stream representation of flowspec including a compressed encoded
length of flowspec.
<P>Sometimes in code, it is used expression flowspec type, it should mean
flowspec component type.
<P>
<P><HR><H3>Function</H3>
<P><I>const char *</I>
<B>flow_type_str</B>
(<I>enum flow_type</I> <B>type</B>, <I>int</I> <B>ipv6</B>) --     get stringified flowspec name of component
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>enum flow_type</I> <B>type</B><DD><P>flowspec component type
<DT><I>int</I> <B>ipv6</B><DD><P>IPv4/IPv6 decide flag, use zero for IPv4 and one for IPv6
</DL>
<H3>Description</H3>
<P>This function returns flowspec name of component <B>type</B> in string.


<HR><H3>Function</H3>
<P><I>uint</I>
<B>flow_write_length</B>
(<I>byte *</I> <B>data</B>, <I>u16</I> <B>len</B>) --     write compressed length value
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>byte *</I> <B>data</B><DD><P>destination buffer to write
<DT><I>u16</I> <B>len</B><DD><P>the value of the length (0 to 0xfff) for writing
</DL>
<H3>Description</H3>
<P>This function writes appropriate as (1- or 2-bytes) the value of <B>len</B> into
buffer <B>data</B>. The function returns number of written bytes, thus 1 or 2 bytes.


<HR><H3>Function</H3>
<P><I>const byte *</I>
<B>flow4_first_part</B>
(<I>const net_addr_flow4 *</I> <B>f</B>) --     get position of the first flowspec component
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>const net_addr_flow4 *</I> <B>f</B><DD><P>flowspec data structure <I>net_addr_flow4</I>
</DL>
<H3>Description</H3>
<P>This function return a position to the beginning of the first flowspec
component in IPv4 flowspec <B>f</B>.


<HR><H3>Function</H3>
<P><I>const byte *</I>
<B>flow6_first_part</B>
(<I>const net_addr_flow6 *</I> <B>f</B>) --     get position of the first flowspec component
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>const net_addr_flow6 *</I> <B>f</B><DD><P>flowspec data structure <I>net_addr_flow6</I>
</DL>
<H3>Description</H3>
<P>This function return a position to the beginning of the first flowspec
component in IPv6 flowspec <B>f</B>.


<HR><H3>Function</H3>
<P><I>const byte *</I>
<B>flow4_next_part</B>
(<I>const byte *</I> <B>pos</B>, <I>const byte *</I> <B>end</B>) --     an iterator over flowspec components in flowspec binary stream
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>const byte *</I> <B>pos</B><DD><P>the beginning of a previous or the first component in flowspec binary
stream
<DT><I>const byte *</I> <B>end</B><DD><P>the last valid byte in scanned flowspec binary stream
</DL>
<H3>Description</H3>
<P>This function returns a position to the beginning of the next component
(to a component type byte) in flowspec binary stream or <I>NULL</I> for the end.


<HR><H3>Function</H3>
<P><I>const byte *</I>
<B>flow6_next_part</B>
(<I>const byte *</I> <B>pos</B>, <I>const byte *</I> <B>end</B>) --     an iterator over flowspec components in flowspec binary stream
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>const byte *</I> <B>pos</B><DD><P>the beginning of a previous or the first component in flowspec binary
stream
<DT><I>const byte *</I> <B>end</B><DD><P>the last valid byte in scanned flowspec binary stream
</DL>
<H3>Description</H3>
<P>This function returns a position to the beginning of the next component
(to a component type byte) in flowspec binary stream or <I>NULL</I> for the end.


<HR><H3>Function</H3>
<P><I>const char *</I>
<B>flow_validated_state_str</B>
(<I>enum flow_validated_state</I> <B>code</B>) --     return a textual description of validation process
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>enum flow_validated_state</I> <B>code</B><DD><P>validation result
</DL>
<H3>Description</H3>
<P>This function return well described validation state in string.


<HR><H3>Function</H3>
<P><I>void</I>
<B>flow_check_cf_bmk_values</B>
(<I>struct flow_builder *</I> <B>fb</B>, <I>u8</I> <B>neg</B>, <I>u32</I> <B>val</B>, <I>u32</I> <B>mask</B>) --     check value/bitmask part of flowspec component
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>struct flow_builder *</I> <B>fb</B><DD><P>flow builder instance
<DT><I>u8</I> <B>neg</B><DD><P>negation operand
<DT><I>u32</I> <B>val</B><DD><P>value from value/mask pair
<DT><I>u32</I> <B>mask</B><DD><P>bitmap mask from value/mask pair
</DL>
<H3>Description</H3>
<P>This function checks value/bitmask pair. If some problem will appear, the
function calls <B>cf_error()</B> function with a textual description of reason
to failing of validation.


<HR><H3>Function</H3>
<P><I>void</I>
<B>flow_check_cf_value_length</B>
(<I>struct flow_builder *</I> <B>fb</B>, <I>u32</I> <B>val</B>) --     check value by flowspec component type
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>struct flow_builder *</I> <B>fb</B><DD><P>flow builder instance
<DT><I>u32</I> <B>val</B><DD><P>value
</DL>
<H3>Description</H3>
<P>This function checks if the value is in range of component's type support.
If some problem will appear, the function calls <B>cf_error()</B> function with
a textual description of reason to failing of validation.


<HR><H3>Function</H3>
<P><I>enum flow_validated_state</I>
<B>flow4_validate</B>
(<I>const byte *</I> <B>nlri</B>, <I>uint</I> <B>len</B>) --     check untrustworthy IPv4 flowspec data stream
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>const byte *</I> <B>nlri</B><DD><P>flowspec data stream without compressed encoded length value
<DT><I>uint</I> <B>len</B><DD><P>length of <B>nlri</B>
</DL>
<H3>Description</H3>
<P>This function checks meaningfulness of binary flowspec. It should return
<I>FLOW_ST_VALID</I> or <I>FLOW_ST_UNKNOWN_COMPONENT</I>. If some problem appears, it
returns some other <I>FLOW_ST_xxx</I> state.


<HR><H3>Function</H3>
<P><I>enum flow_validated_state</I>
<B>flow6_validate</B>
(<I>const byte *</I> <B>nlri</B>, <I>uint</I> <B>len</B>) --     check untrustworthy IPv6 flowspec data stream
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>const byte *</I> <B>nlri</B><DD><P>flowspec binary stream without encoded length value
<DT><I>uint</I> <B>len</B><DD><P>length of <B>nlri</B>
</DL>
<H3>Description</H3>
<P>This function checks meaningfulness of binary flowspec. It should return
<I>FLOW_ST_VALID</I> or <I>FLOW_ST_UNKNOWN_COMPONENT</I>. If some problem appears, it
returns some other <I>FLOW_ST_xxx</I> state.


<HR><H3>Function</H3>
<P><I>void</I>
<B>flow4_validate_cf</B>
(<I>net_addr_flow4 *</I> <B>f</B>) --     validate flowspec data structure <I>net_addr_flow4</I> in parsing time
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>net_addr_flow4 *</I> <B>f</B><DD><P>flowspec data structure <I>net_addr_flow4</I>
</DL>
<H3>Description</H3>
<P>Check if <B>f</B> is valid flowspec data structure. Can call <B>cf_error()</B> function
with a textual description of reason to failing of validation.


<HR><H3>Function</H3>
<P><I>void</I>
<B>flow6_validate_cf</B>
(<I>net_addr_flow6 *</I> <B>f</B>) --     validate flowspec data structure <I>net_addr_flow6</I> in parsing time
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>net_addr_flow6 *</I> <B>f</B><DD><P>flowspec data structure <I>net_addr_flow6</I>
</DL>
<H3>Description</H3>
<P>Check if <B>f</B> is valid flowspec data structure. Can call <B>cf_error()</B> function
with a textual description of reason to failing of validation.


<HR><H3>Function</H3>
<P><I>struct flow_builder *</I>
<B>flow_builder_init</B>
(<I>pool *</I> <B>pool</B>) --     constructor for flowspec builder instance
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>pool *</I> <B>pool</B><DD><P>memory pool
</DL>
<H3>Description</H3>
<P>This function prepares flowspec builder instance using memory pool <B>pool</B>.


<HR><H3>Function</H3>
<P><I>int</I>
<B>flow_builder4_add_pfx</B>
(<I>struct flow_builder *</I> <B>fb</B>, <I>const net_addr_ip4 *</I> <B>n4</B>) --     add IPv4 prefix
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>struct flow_builder *</I> <B>fb</B><DD><P>flowspec builder instance
<DT><I>const net_addr_ip4 *</I> <B>n4</B><DD><P>net address of type IPv4
</DL>
<H3>Description</H3>
<P>This function add IPv4 prefix into flowspec builder instance.


<HR><H3>Function</H3>
<P><I>int</I>
<B>flow_builder6_add_pfx</B>
(<I>struct flow_builder *</I> <B>fb</B>, <I>const net_addr_ip6 *</I> <B>n6</B>, <I>u32</I> <B>pxoffset</B>) --     add IPv6 prefix
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>struct flow_builder *</I> <B>fb</B><DD><P>flowspec builder instance
<DT><I>const net_addr_ip6 *</I> <B>n6</B><DD><P>net address of type IPv4
<DT><I>u32</I> <B>pxoffset</B><DD><P>prefix offset for <B>n6</B>
</DL>
<H3>Description</H3>
<P>This function add IPv4 prefix into flowspec builder instance. This function
should return 1 for successful adding, otherwise returns <I>0</I>.


<HR><H3>Function</H3>
<P><I>int</I>
<B>flow_builder_add_op_val</B>
(<I>struct flow_builder *</I> <B>fb</B>, <I>byte</I> <B>op</B>, <I>u32</I> <B>value</B>) --     add operator/value pair
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>struct flow_builder *</I> <B>fb</B><DD><P>flowspec builder instance
<DT><I>byte</I> <B>op</B><DD><P>operator
<DT><I>u32</I> <B>value</B><DD><P>value
</DL>
<H3>Description</H3>
<P>This function add operator/value pair as a part of a flowspec component. It
is required to set appropriate flowspec component type using function
<B>flow_builder_set_type()</B>. This function should return 1 for successful
adding, otherwise returns 0.


<HR><H3>Function</H3>
<P><I>int</I>
<B>flow_builder_add_val_mask</B>
(<I>struct flow_builder *</I> <B>fb</B>, <I>byte</I> <B>op</B>, <I>u32</I> <B>value</B>, <I>u32</I> <B>mask</B>) --     add value/bitmask pair
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>struct flow_builder *</I> <B>fb</B><DD><P>flowspec builder instance
<DT><I>byte</I> <B>op</B><DD><P>operator
<DT><I>u32</I> <B>value</B><DD><P>value
<DT><I>u32</I> <B>mask</B><DD><P>bitmask
</DL>
<H3>Description</H3>
<P>It is required to set appropriate flowspec component type using function
<B>flow_builder_set_type()</B>. This function should return 1 for successful adding,
otherwise returns 0.


<HR><H3>Function</H3>
<P><I>void</I>
<B>flow_builder_set_type</B>
(<I>struct flow_builder *</I> <B>fb</B>, <I>enum flow_type</I> <B>type</B>) --     set type of next flowspec component
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>struct flow_builder *</I> <B>fb</B><DD><P>flowspec builder instance
<DT><I>enum flow_type</I> <B>type</B><DD><P>flowspec component type
</DL>
<H3>Description</H3>
<P>This function sets type of next flowspec component. It is necessary to call
this function before each changing of adding flowspec component.


<HR><H3>Function</H3>
<P><I>net_addr_flow4 *</I>
<B>flow_builder4_finalize</B>
(<I>struct flow_builder *</I> <B>fb</B>, <I>linpool *</I> <B>lpool</B>) --     assemble final flowspec data structure <I>net_addr_flow4</I>
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>struct flow_builder *</I> <B>fb</B><DD><P>flowspec builder instance
<DT><I>linpool *</I> <B>lpool</B><DD><P>linear memory pool
</DL>
<H3>Description</H3>
<P>This function returns final flowspec data structure <I>net_addr_flow4</I> allocated
onto <B>lpool</B> linear memory pool.


<HR><H3>Function</H3>
<P><I>net_addr_flow6 *</I>
<B>flow_builder6_finalize</B>
(<I>struct flow_builder *</I> <B>fb</B>, <I>linpool *</I> <B>lpool</B>) --     assemble final flowspec data structure <I>net_addr_flow6</I>
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>struct flow_builder *</I> <B>fb</B><DD><P>flowspec builder instance
<DT><I>linpool *</I> <B>lpool</B><DD><P>linear memory pool for allocation of
</DL>
<H3>Description</H3>
<P>This function returns final flowspec data structure <I>net_addr_flow6</I> allocated
onto <B>lpool</B> linear memory pool.


<HR><H3>Function</H3>
<P><I>void</I>
<B>flow_builder_clear</B>
(<I>struct flow_builder *</I> <B>fb</B>) --     flush flowspec builder instance for another flowspec creation
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>struct flow_builder *</I> <B>fb</B><DD><P>flowspec builder instance
</DL>
<H3>Description</H3>
<P>This function flushes all data from builder but it maintains pre-allocated
buffer space.


<HR><H3>Function</H3>
<P><I>uint</I>
<B>flow4_net_format</B>
(<I>char *</I> <B>buf</B>, <I>uint</I> <B>blen</B>, <I>const net_addr_flow4 *</I> <B>f</B>) --     stringify flowspec data structure <I>net_addr_flow4</I>
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>char *</I> <B>buf</B><DD><P>pre-allocated buffer for writing a stringify net address flowspec
<DT><I>uint</I> <B>blen</B><DD><P>free allocated space in <B>buf</B>
<DT><I>const net_addr_flow4 *</I> <B>f</B><DD><P>flowspec data structure <I>net_addr_flow4</I> for stringify
</DL>
<H3>Description</H3>
<P>This function writes stringified <B>f</B> into <B>buf</B>. The function returns number
of written chars. If final string is too large, the string will ends the with
' ...}' sequence and zero-terminator.


<HR><H3>Function</H3>
<P><I>uint</I>
<B>flow6_net_format</B>
(<I>char *</I> <B>buf</B>, <I>uint</I> <B>blen</B>, <I>const net_addr_flow6 *</I> <B>f</B>) --     stringify flowspec data structure <I>net_addr_flow6</I>
<P>
<H3>Arguments</H3>
<P>
<DL>
<DT><I>char *</I> <B>buf</B><DD><P>pre-allocated buffer for writing a stringify net address flowspec
<DT><I>uint</I> <B>blen</B><DD><P>free allocated space in <B>buf</B>
<DT><I>const net_addr_flow6 *</I> <B>f</B><DD><P>flowspec data structure <I>net_addr_flow4</I> for stringify
</DL>
<H3>Description</H3>
<P>This function writes stringified <B>f</B> into <B>buf</B>. The function returns number
of written chars. If final string is too large, the string will ends the with
' ...}' sequence and zero-terminator.

<P>
<HR>
<A HREF="prog-8.html">Next</A>
<A HREF="prog-6.html">Previous</A>
<A HREF="prog.html#toc7">Contents</A>
</BODY>
</HTML>
